#!/usr/bin/env node
var util = require(process.binding('natives').util ? 'util' : 'sys');
var path = require('path');

var ROOT_PATH, LIB_PATH;

//Build path
ROOT_PATH = path.dirname(__dirname);
LIB_PATH = path.join(path.dirname(__dirname), 'lib');
require.paths.unshift(LIB_PATH);


//Include lint library
var lint = require('lint');
var Launcher = lint.Launcher;




var usage, args, positionals, launcher, options, configFile;

//called as main executable

usage = "Usage: " + process.ARGV[0] + " file.js [dir1 file2 dir2 ...] [options]\n" +
"Options:\n\n" +
"  --config=FILE     the path to a JSON file with JSLINT options\n" +
"  --formatter=FILE   optional path to a /dir/dir/file.hs file to customize the output\n" +
"  -h, --help        display this help and exit\n" +
"  -v, --version     output version information and exit";

args = process.ARGV.splice(2);
positionals = [];
options = {
    formatter: {
    },
    parser: {
    }
};
configFile = process.env.NODELINT_CONFIG_FILE;
  
launcher = new Launcher();
while (args.length !== 0) {
    arg = args.shift();
    switch (arg) {
    case '-v':
    case '--version':
        var content, pkg;
        content = fs.readFileSync(path.join(__filename, '..', '..', '..', 'package.json'), 'utf8');
        pkg = JSON.parse(content);
        util.puts(pkg.version);
        process.exit(0);
        break;
    case '-h':
    case '--help':  
        util.puts(usage);
        process.exit(0);
        break;
    case '--silent':
        options.silent = true;
        break;
    case '--pretty':
        options.formatter.pretty = true;
        break;
    case '--no-color':
    case '--no-colors':
        options.formatter.colors = false;
        break;
    default:
        if (arg.indexOf('--formatter') >= 0) {
            options.formatter.type = 'callback';
            options.formatter.callback = fs.readFileSync(arg.split('=')[1], 'utf8');
        } else if (arg.indexOf('--format') >= 0) {
            options.formatter.type = arg.split('=')[1];
        } else if (arg.indexOf('--mode') >= 0) {
            options.formatter.mode = arg.split('=')[1];
        } else if (arg.indexOf('--config') >= 0) {
            var file, source;
            
            configFile = arg.split('=')[1];
            
        } else {
            positionals.push(arg);
        }
    }
}

//Load default config file from environment
if (configFile) {
    var source;
    
    //read config file
    try {
        source = fs.readFileSync(configFile, 'utf8');
    } catch (e) {
        launcher.printError('Read error when accessing "' + configFile + '".');
    }
    
    //Remove comments
    source = source.replace(/\/\*.+?\*\/|\/\/.*(?=[\n\r])/g, '');

    //Parse config
    try {
        source = JSON.parse(source);
    } catch (e) {
        console.log(e.toString());
        launcher.printError('Parse Error in "' + configFile + '"');
    }
    
    
    try {
        launcher.configure(source);
    } catch (e) {
        console.log(e.toString());
        launcher.printError('Parse Error in "' + configFile + '"');
    }
}

try {
    launcher.configure(options);
} catch (e) {
    launcher.printError('Configuration : ' + e.toString());
}

try {
    launcher.run(positionals);
} catch (e) {
    launcher.printError('Execution : ' + e.toString());
}


